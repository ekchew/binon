#ifndef BINON_HASHUTIL_HPP
#define BINON_HASHUTIL_HPP

#include "byteutil.hpp" // for the CHAR_BIT assertion

#include <concepts>
#include <functional>

namespace binon {

 BINON_IF_CONCEPTS(
	template<typename T>
		concept Hashable = requires(T a) {
			{ std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
		};
 )

	//---- Hash Combination ---------------------------------------------------
	//
	//	While the standard library provides std::hash support for common types,
	//	compound data structures such as tuples and structs have no obvious way
	//	of building up a single hash value from the hashes of their individual
	//	data members. These methods try to help with that.

	//	HashCombine function
	//
	//	Given 1 or more std::size_t hash values of the kind generated by
	//	std::hash, this function returns a single std::size_t that combines
	//	them.
	//
	//	Template args:
	//		V, Vs...: inferred from "v" and "vs" function args, respectively
	//
	//	Function args:
	//		v: the first size_t value
	//			You must supply at least 1.
	//		vs...: any remaining size_t values
	//
	//	Returns:
	//		combined size_t hash
	//
	template<BINON_CONCEPT(std::convertible_to<std::size_t>)... Vs> constexpr
		auto HashCombine(std::size_t v, Vs... vs) noexcept {
			using std::size_t;

			//	This lambda combines 2 hashes into 1. The algorithm was
			//	borrowed from the boost library with one modification.
			//	The magic number boost uses is 32-bit, but size_t is often a
			//	64-bit type these days. Since the number is based on the so-
			//	called "golden ratio", this has been extended to 64 bits when
			//	sizeof(size_t) > 4.
			auto combine2 = [](size_t a, size_t b) constexpr noexcept
				-> size_t
			{
				auto magic = sizeof a > 4U ? 0x9e3779b97f4a7c15 : 0x9e3779b9;
				return a ^ (b + magic + (a << 6) + (a >> 2));
			};

			//	Use combine2 as a custom fold function to fold all the args.
			return (
				MakeCustomFold<size_t>(v,  combine2) + ... +
				MakeCustomFold<size_t>(vs, combine2)
				);
		}

	//	HashCombineObjs function
	//
	//	This function generates hashes for each argument you supply and
	//	combines them into a single hash by calling HashCombine().
	//
	//	Template args:
	//		Vs: inferred from "vs" function arg
	//
	//	Function args:
	//		vs...: the args to hash
	//			Each of these must support std::hash hashing, and there must be
	//			at least one value.
	//
	//	Returns:
	//		std::size_t: the combined hash value
	//
	template<BINON_CONCEPT(Hashable)... Vs> constexpr
		auto HashCombineObjs(const Vs&... vs) -> std::size_t {
			return HashCombine(std::hash<Vs>{}(vs)...);
		}

	//---- CommutativeHash class ----------------------------------------------
	//
	//	CummutativeHash helps you combine hash values in a commutative manner.
	//	That way, you should get the same final result regardless of the order
	//	in which you combine them.
	//
	//	Such an algorithm is needed if you want to hash any of the
	//	std::unordered_... containers. The algorithm used here is based on what
	//	Python uses for frozenset hashing. Since said algorithm has a specific
	//	seed value and finalization step, it has been implemented here as a
	//	class rather than a simple function.

	struct CommutativeHash {
		std::size_t mHash = 1927868237UL;
	 public:

		//	The extend() method combines a new hash value with the one that is
		//	currently stored.
		void extend(std::size_t hashVal);

		//	You can call a CommutativeHash instance as a functor with any
		//	hashable value as its sole argument. It will then hash said value
		//	and call extend on it.
		template<BINON_CONCEPT(Hashable) T>
			void operator() (const T& v) { extend(std::hash<T>{}(v)); }

		//	The get() method finalizes the combined hash and returns it to you.
		//	(You can still extend the hash afterwards and call get() again.)
		//	CommutativeHash also implements a conversion operator to size_t that
		//	calls get implicitly.
		auto get() const -> std::size_t;
		operator std::size_t() const { return get(); }
	};

	//	This is nothing more than a random number generated at program launch
	//	you can apply to your hash values with a simple bitwise-xor (^)
	//	operation. It will ensure that every time your program runs, it will use
	//	different hash values. This can protect you against certain types of
	//	DDOS attacks.
	//
	//	Note that the std::hash specialization for BinONObj already applies the
	//	salt. (It rotates the salt by 1 bit left before the xor though in case
	//	you forget and xor it anyway.)
	//
	//	(A few technical notes. While gHashSalt may not have been declared
	//	const, you should not be going around changing it all the time. Once
	//	possible scenario for changing it would be if your project includes
	//	subprocesses and you want them to all share the same salt. Another would
	//	be if your program runs a long time and you want to periodically refresh
	//	the salt. In this case though, it is your responsibility to make sure
	//	nothing is still relying on the old salt before you do so. Also note
	//	that due to the generally read-only nature of gHashSalt, it has NOT been
	//	declared atomic.)
	extern std::size_t gHashSalt;
}

#endif
