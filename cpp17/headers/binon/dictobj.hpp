#ifndef BINON_DICTOBJ_HPP
#define BINON_DICTOBJ_HPP

#include "binonobj.hpp"

#include <mutex>
#include <optional>
#include <sstream>

namespace binon {
	
	auto DeepCopyTDict(const TDict& dict) -> TDict;
	void PrintTDictRepr(const TDict& list, std::ostream& stream);
	
	struct NoDictVal: std::logic_error {
		using std::logic_error::logic_error;
	};
	
	//	Abstract base class of DictObj, SKDict, and SDict that implements some
	//	shared functionality.
	struct DictBase: BinONObj {
		
		//	Returns the unordered_map (TDict) that stores all the key and value
		//	shared pointers.
		virtual auto dict() noexcept -> TDict& = 0;
		const auto& dict() const noexcept
			{ return const_cast<DictBase*>(this)->dict(); }
		
		//	hasKey() checks if a given key is already in the dict. hasValue()
		//	further checks if the associated value has been allocated (as a
		//	shared pointer).
		//
		//	Each of these methods (along with other accessors you see further
		//	down) can accept the key in one of two forms. The first is the
		//	lower-level shared pointer form in which keys exist in the TDict.
		//	The second is an R-value reference to a binon object. This lets
		//	you go, for example:
		//
		//		if(myDict.hasKey(StrObj("foo"))) {/*...*/}
		//
		//	(There is no copy semantics version of the latter. The idea is if
		//	you want to re-use the key in multiple calls, you are better off
		//	allocating it as a pointer and making the lower-level call.)
		//
		auto hasKey(const TSPBinONObj& pKey) const -> bool;
		auto hasKey(BinONObj&& key) const -> bool
			{ return hasKey(key.makeCopy()); }
		auto hasValue(const TSPBinONObj& pKey) const -> bool;
		auto hasValue(BinONObj&& key) const -> bool
			{ return hasValue(key.makeCopy()); }
		
		//	value() returns a reference to the binon object corresponding to a
		//	given key. If no value exists, a new one is allocated using the
		//	default constructor. In other words, this works like the []
		//	operator in an unordered_map except you need to specify the return
		//	type. value() will, in fact, throw a TypeErr exception if you get
		//	this wrong.
		template<typename VObj> auto value(const TSPBinONObj& pKey) -> VObj&;
		template<typename VObj> auto value(BinONObj&& key) -> VObj&
			{ return value<VObj>(key.makeCopy()); }
		
		//	valueAt() differs from value() in that the value must exist in the
		//	dictionary already. If the key does not exist, valueAt() will
		//	throw std::out_of_range. (This is actually generated by an
		//	internal call to unordered_map's at() method.) If the key exists
		//	but the value has not been allocated, valueAt() will throw
		//	NullDeref (a subclass of std::out_of_range).
		template<typename VObj>
			auto valueAt(const TSPBinONObj& pKey) -> VObj&;
		template<typename VObj>
			auto valueAt(const TSPBinONObj& pKey) const -> const VObj&
				{ return const_cast<DictBase*>(this)->valueAt<VObj>(pKey); }
		template<typename VObj>
			auto valueAt(BinONObj&& key) -> VObj&
				{ return valueAt<VObj>(key.makeCopy()); }
		template<typename VObj>
			auto valueAt(BinONObj&& key) const -> const VObj&
				{ return valueAt<VObj>(key.makeCopy()); }
	
	private:
		
		//	Dynamic-casts a shared pointer to a dictionary value to the
		//	specified type and throws TypeErr if the cast fails. It assumes
		//	the original pointer is not the null_ptr.
		template<typename VObj>
			static auto CastValue(TSPBinONObj& pObj)
				-> std::shared_ptr<VObj>;
		template<typename VObj>
			static auto CastValue(const TSPBinONObj& pObj)
				-> const std::shared_ptr<VObj> {
					return CastValue<VObj>(const_cast<TSPBinONObj&>(pObj));
				}
	};
	
	struct DictObj: DictBase, AccessContainer_mValue<DictObj,TDict> {
		TValue mValue;
		
		DictObj(const TDict& v): mValue{v} {}
		DictObj(TDict&& v) noexcept: mValue{std::move(v)} {}
		DictObj() noexcept = default;
		explicit operator bool() const noexcept override
			{ return mValue.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue; }
		auto typeCode() const noexcept -> CodeByte final {return kDictObjCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> const char* override
			{ return "DictObj"; }
		void printArgsRepr(std::ostream& stream) const override
			{ PrintTDictRepr(mValue, stream); }
	};
	
	struct SKDictVal {
		CodeByte mKeyCode = kIntObjCode;
		TDict mDict;
	};
	struct SKDict: DictBase, AccessContainer_mValue<SKDict,SKDictVal> {
		TValue mValue;
		
		SKDict(CodeByte keyCode) noexcept: mValue{keyCode} {}
		SKDict(const SKDictVal& v): mValue{v} {}
		SKDict(SKDictVal&& v) noexcept: mValue{std::move(v)} {}
		SKDict(const SKDict& obj) = default;
		SKDict(SKDict&& obj) noexcept = default;
		SKDict() noexcept = default;
		explicit operator bool() const noexcept override
			{ return mValue.mDict.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue.mDict; }
		auto typeCode() const noexcept -> CodeByte final {return kSKDictCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> const char* override
			{ return "SKDict"; }
		void printArgsRepr(std::ostream& stream) const override;
	};

	struct SDictVal {
		CodeByte mKeyCode = kIntObjCode;
		CodeByte mValCode = kIntObjCode;
		TDict mDict;
	};
	struct SDict: DictBase, AccessContainer_mValue<SDict,SDictVal> {
		TValue mValue;
		
		SDict(CodeByte keyCode, CodeByte valCode=kIntObjCode) noexcept:
			mValue{keyCode, valCode} {}
		SDict(const SDictVal& v): mValue{v} {}
		SDict(SDictVal&& v) noexcept: mValue{std::move(v)} {}
		SDict(const SDict& obj) = default;
		SDict(SDict&& obj) noexcept = default;
		SDict() noexcept = default;
		auto operator = (const SDict&) -> SDict& = default;
		auto operator = (SDict&&) noexcept -> SDict& = default;
		explicit operator bool() const noexcept override
			{ return mValue.mDict.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue.mDict; }
		auto typeCode() const noexcept -> CodeByte final {return kSDictCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> const char* override 
			{ return "SDict"; }
		void printArgsRepr(std::ostream& stream) const override;
	};
	
	//---- Template Implementation ---------------------------------------------
	
	template<typename VObj>
	auto DictBase::value(const TSPBinONObj& pKey) -> VObj& {
		auto& dct = dict();
		auto it = dct.find(pKey);
		std::shared_ptr<VObj> pVal;
		if(it == dct.end()) {
			pVal = std::make_shared<VObj>();
			dct.insert(it, std::make_pair(pKey, pVal));
			return *pVal;
		}
		else if(!it->second) {
			pVal = std::make_shared<VObj>();
			it->second = pVal;
		}
		else {
			pVal = CastValue<VObj>(it->second);
		}
		return *pVal;
	}
	template<typename VObj>
		auto DictBase::valueAt(const TSPBinONObj& pKey) -> VObj&
	{
		auto pObj = dict().at(pKey);
		if(!pObj) {
			throw NullDeref{"binon::TDict value not allocated"};
		}
		return *pObj;
	}
	template<typename VObj>
	auto DictBase::CastValue(TSPBinONObj& pObj) -> std::shared_ptr<VObj> {
		auto pVObj = std::dynamic_pointer_cast<VObj>(pObj);
		if(!pVObj) {
			throw TypeErr{"binon::TDict value cannot cast to requested type"};
		}
		return pVObj;
	}
}

#endif
