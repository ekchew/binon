#ifndef BINON_DICTOBJ_HPP
#define BINON_DICTOBJ_HPP

#include "listobj.hpp"

#include <functional>
#include <optional>
#include <sstream>

namespace binon {

	auto DeepCopyTDict(const TDict& dict) -> TDict;
	void PrintTDictRepr(const TDict& list, std::ostream& stream);

	struct NoDictVal: std::logic_error {
		using std::logic_error::logic_error;
	};

	//	Abstract base class of DictObj, SKDict, and SDict that implements some
	//	shared functionality.
	struct DictBase: BinONObj {

		//	Returns the unordered_map (TDict) that stores all the key and value
		//	shared pointers.
		virtual auto dict() noexcept -> TDict& = 0;
		auto dict() const noexcept -> const TDict&
			{ return const_cast<DictBase*>(this)->dict(); }

		//	hasKey() indicates whether a key you specify exists in the
		//	dictionary. The low-level form takes the key as a shared pointer
		//	the way it would be stored in the dictionary. There is also an
		//	overloaded form in which you specify the key class and constructor
		//	arguments, and it makes a temporary shared pointer to look up.
		//	This lets you, for example, write:
		//
		//		if(myDict.hasKey<StrObj>("foo")) {/*...*/}
		//
		auto hasKey(const TSPBinONObj& pKey) const -> bool;
		template<typename Key, typename... Args>
			auto hasKey(Args&&... args) const -> bool;

		//	Even if a key exists, it's associated value may not have been
		//	allocated. (Values are also stored as shared pointers in the
		//	dictionary.) hasValue() returns true if and only if both the key
		//	exists and it's value actually points to an object.
		auto hasValue(const TSPBinONObj& pKey) const -> bool;
		template<typename Key, typename... Args>
			auto hasValue(Args&&... args) const -> bool;

		//	valueAt() returns a reference to the value associated with a given
		//	key. It must succeed at locating this value. If the key does not
		//	exist, it throws std::out_of_range (as generated by an internal
		//	call to unordered_map's at() method). If the key exists but the
		//	value is not allocated, it throws NullDeref (a subclass of
		//	std::out_of_range). If the value exists but is not of the type
		//	you specify in the Val template argument, it throws TypeErr.
		//
		//	As with hasKey(), the method can accept either a shared pointer to
		//	a key or a list of arguments to build a key on-the-fly. In the
		//	latter case, you must specify both the key and value types as
		//	template arguments. The former case only expects the value type.
		//
		template<typename Val>
			auto valueAt(const TSPBinONObj& pKey) -> Val&;
		template<typename Val>
			auto valueAt(const TSPBinONObj& pKey) const -> const Val&;
		template<typename Key, typename Val, typename... Args>
			auto valueAt(Args&&... args) -> Val&;
		template<typename Key, typename Val, typename... Args>
			auto valueAt(Args&&... args) const -> const Val&;

		//	value() is like valueAt() except in the event that no value for your
		//	key exists yet in the dictionary, a new one will be allocated using
		//	the default constructor. In other words, it works more or less like
		//	the [] operator in a map class except you must still supply the
		//	value type in a template argument.
		template<typename Val>
			auto value(const TSPBinONObj& pKey) -> Val&;
		template<typename Key, typename Val, typename... Args>
			auto value(Args&&... args) -> Val&;
	};

	struct DictObj: DictBase, AccessContainer_mValue<DictObj,TDict> {
		static void EncodeData(
			const TValue& v, TOStream& stream, bool requireIO=true);
		static auto DecodeData(TIStream& stream, bool requireIO=true) -> TValue;

		TValue mValue;

		DictObj(const TDict& v): mValue{v} {}
		DictObj(TDict&& v) noexcept: mValue{std::move(v)} {}
		DictObj() noexcept = default;
		explicit operator bool() const noexcept override
			{ return mValue.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue; }
		auto typeCode() const noexcept -> CodeByte final {return kDictObjCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> std::string override
			{ return "DictObj"; }
		void printArgsRepr(std::ostream& stream) const override
			{ PrintTDictRepr(mValue, stream); }
	};

	struct SKDictVal {
		CodeByte mKeyCode = kIntObjCode;
		TDict mDict;
	};
	struct SKDict: DictBase, AccessContainer_mValue<SKDict,SKDictVal> {
		static void EncodeData(
			const TValue& v, TOStream& stream, bool requireIO=true);
		static auto DecodeData(TIStream& stream, bool requireIO=true) -> TValue;

		TValue mValue;

		SKDict(CodeByte keyCode) noexcept: mValue{keyCode} {}
		SKDict(const SKDictVal& v): mValue{v} {}
		SKDict(SKDictVal&& v) noexcept: mValue{std::move(v)} {}
		SKDict(const SKDict& obj) = default;
		SKDict(SKDict&& obj) noexcept = default;
		SKDict() noexcept = default;
		explicit operator bool() const noexcept override
			{ return mValue.mDict.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue.mDict; }
		auto typeCode() const noexcept -> CodeByte final {return kSKDictCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> std::string override
			{ return "SKDict"; }
		void printArgsRepr(std::ostream& stream) const override;
	};

	struct SDictVal {
		CodeByte mKeyCode = kIntObjCode;
		CodeByte mValCode = kIntObjCode;
		TDict mDict;
	};
	struct SDict: DictBase, AccessContainer_mValue<SDict,SDictVal> {
		static void EncodeData(
			const TValue& v, TOStream& stream, bool requireIO=true);
		static auto DecodeData(TIStream& stream, bool requireIO=true) -> TValue;

		TValue mValue;

		SDict(CodeByte keyCode, CodeByte valCode=kIntObjCode) noexcept:
			mValue{keyCode, valCode} {}
		SDict(const SDictVal& v): mValue{v} {}
		SDict(SDictVal&& v) noexcept: mValue{std::move(v)} {}
		SDict(const SDict& obj) = default;
		SDict(SDict&& obj) noexcept = default;
		SDict() noexcept = default;
		auto operator = (const SDict&) -> SDict& = default;
		auto operator = (SDict&&) noexcept -> SDict& = default;
		explicit operator bool() const noexcept override
			{ return mValue.mDict.size() != 0; }
		auto dict() noexcept -> TDict& final { return mValue.mDict; }
		auto typeCode() const noexcept -> CodeByte final {return kSDictCode;}
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> std::string override
			{ return "SDict"; }
		void printArgsRepr(std::ostream& stream) const override;
	};

	template<
		typename K,
		typename Ctnr = std::unordered_map<K,TSPBinONObj>
		>
	struct SKDictT: BinONObj {
		using TKey = K;
		using TCtnr = Ctnr;
		using TKeyWrap = TWrapper<TKey>;
		using TKeyRW = std::reference_wrapper<TKey>;
		using TKeyVal = typename TCtnr::value_type;

		static void EncodeData(
			const TCtnr& v, TOStream& stream, bool requireIO=true);
		static auto DecodeData(TIStream& stream, bool requireIO=true) -> TCtnr;

		Ctnr mValue;

		SKDictT(std::initializer_list<TKeyVal> lst);
		SKDictT(const SKDict& dict);
		SKDictT(const TCtnr& ctnr);
		SKDictT(TCtnr&& ctnr) noexcept;
		SKDictT() noexcept = default;
		operator TCtnr&() noexcept;
		operator const TCtnr&() const noexcept;
		explicit operator bool() const noexcept override;
		auto typeCode() const noexcept -> CodeByte final;
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> std::string override;
		void printArgsRepr(std::ostream& stream) const override;

		//---- TCtnr API -------------------------------------------------------

		using key_type = typename TCtnr::key_type;
		using mapped_type = typename TCtnr::mapped_type;
		using value_type = typename TCtnr::value_type;
		using size_type = typename TCtnr::size_type;
		template<typename Obj=BinONObj>
			auto at(const key_type& key) -> Obj& {
				return *BinONObj::Cast<TWrapper<Obj>>(mValue.at(key));
			}
		template<typename Obj=BinONObj>
			auto at(const key_type& key) const -> const Obj& {
				return const_cast<SKDictT*>(this)->at<Obj>(key);
			}
		const auto& at(const key_type& key) const { return mValue.at(key); }
		auto begin() noexcept { return mValue.begin(); }
		auto begin() const noexcept { return mValue.begin(); }
		void clear() noexcept { mValue.clear(); }
		auto contains(const key_type& key) const
			{ return mValue.find(key) != end(); }
		auto end() noexcept { return mValue.end(); }
		auto end() const noexcept { return mValue.end(); }
		auto size() const noexcept { return mValue.size(); }
	};

	template<
		typename K,
		typename V,
		typename Ctnr = std::unordered_map<K,V>
		>
	struct SDictT: BinONObj {
		using TKey = K;
		using TVal = V;
		using TCtnr = Ctnr;
		using TKeyWrap = TWrapper<TKey>;
		using TKeyRW = std::reference_wrapper<TKey>;
		using TValWrap = TWrapper<TVal>;
		using TValRW = std::reference_wrapper<TVal>;
		using TKeyVal = typename TCtnr::value_type;

		static void EncodeData(
			const TCtnr& v, TOStream& stream, bool requireIO=true);
		static auto DecodeData(TIStream& stream, bool requireIO=true) -> TCtnr;

		Ctnr mValue;

		SDictT(std::initializer_list<TKeyVal> lst);
		SDictT(const SDict& dict);
		SDictT(const TCtnr& ctnr);
		SDictT(TCtnr&& ctnr) noexcept;
		SDictT() noexcept = default;
		operator TCtnr&() noexcept;
		operator const TCtnr&() const noexcept;
		explicit operator bool() const noexcept override;
		auto typeCode() const noexcept -> CodeByte final;
		void encodeData(TOStream& stream, bool requireIO=true) const final;
		void decodeData(TIStream& stream, bool requireIO=true) final;
		auto makeCopy(bool deep=false) const -> TSPBinONObj override;
		auto clsName() const noexcept -> std::string override;
		void printArgsRepr(std::ostream& stream) const override;

		//---- TCtnr API -------------------------------------------------------

		using key_type = typename TCtnr::key_type;
		using mapped_type = typename TCtnr::mapped_type;
		using value_type = typename TCtnr::value_type;
		using size_type = typename TCtnr::size_type;
		auto& at(const key_type& key) { return mValue.at(key); }
		const auto& at(const key_type& key) const { return mValue.at(key); }
		auto begin() noexcept { return mValue.begin(); }
		auto begin() const noexcept { return mValue.begin(); }
		void clear() noexcept { mValue.clear(); }
		auto contains(const key_type& key) const { return find(key) != end(); }
		auto end() noexcept { return mValue.end(); }
		auto end() const noexcept { return mValue.end(); }
		auto size() const noexcept { return mValue.size(); }
	};

	//==== Template Implementation =============================================

	//---- DictBase ------------------------------------------------------------

	template<typename Key, typename... Args>
	auto DictBase::hasKey(Args&&... args) const -> bool {
		auto pKey = std::make_shared<Key>(std::forward<Args>(args)...);
		return hasKey(std::move(pKey));
	}
	template<typename Key, typename... Args>
	auto DictBase::hasValue(Args&&... args) const -> bool {
		auto pKey = std::make_shared<Key>(std::forward<Args>(args)...);
		return hasValue(std::move(pKey));
	}
	template<typename Val>
	auto DictBase::valueAt(const TSPBinONObj& pKey) -> Val& {
		return *BinONObj::Cast<Val>(dict().at(pKey));
	}
	template<typename Val>
	auto DictBase::valueAt(const TSPBinONObj& pKey) const -> const Val& {
		return const_cast<DictBase*>(this)->valueAt<Val>(pKey);
	}
	template<typename Key, typename Val, typename... Args>
	auto DictBase::valueAt(Args&&... args) -> Val& {
		auto pKey = std::make_shared<Key>(std::forward<Args>(args)...);
		return valueAt<Val>(std::move(pKey));
	}
	template<typename Key, typename Val, typename... Args>
	auto DictBase::valueAt(Args&&... args) const -> const Val& {
		auto mutThis = const_cast<DictBase*>(this);
		return mutThis->valueAt<Key,Val>(std::forward<Args>(args)...);
	}
	template<typename Val>
	auto DictBase::value(const TSPBinONObj& pKey) -> Val& {
		auto& dct = dict();
		auto iter = dct.find(pKey);
		std::shared_ptr<Val> pVal;
		if(iter == dct.end()) {
			pVal = std::make_shared<Val>();
			dct.insert(iter, std::make_pair(pKey, pVal));
		}
		else if(!iter->second) {
			iter->second = pVal = std::make_shared<Val>();
		}
		else {
			pVal = BinONObj::Cast<Val>(iter->second);
		}
		return *pVal;
	}
	template<typename Key, typename Val, typename... Args>
	auto DictBase::value(Args&&... args) -> Val& {
		auto pKey = std::make_shared<Key>(std::forward<Args>(args)...);
		return value<Val>(pKey);
	}

	//---- SKDictT -------------------------------------------------------------

	template<typename K, typename Ctnr>
	void SKDictT<K,Ctnr>::EncodeData(
		const TCtnr& v, TOStream& stream, bool requireIO)
	{
		RequireIO rio{stream, requireIO};
		UIntObj::EncodeData(v.size(), stream, kSkipRequireIO);

		EncodeElems<TKey>(
			PipeGenRefs<TKeyRW>(
				IterGen{v.begin(), v.end()},
				[](auto& kv) -> TKeyRW { return const_cast<TKey&>(kv.first); }
			), stream, kSkipRequireIO);

		ListObj::EncodeElems(
			PipeGenRefs<TSPBinONObj>(
				IterGen{v.begin(), v.end()},
				[](auto& kv) { return kv.second; }
			), stream, kSkipRequireIO);
	}
	template<typename K, typename Ctnr>
	auto SKDictT<K,Ctnr>::DecodeData(TIStream& stream, bool requireIO)
		-> TCtnr
	{
		RequireIO rio{stream, requireIO};
		auto keys = SListT<TKey>::DecodeData(stream, kSkipRequireIO);
		auto valGen = ListObj::DecodedElemsGen(
			stream, keys.size(), kSkipRequireIO);
		auto keyIt = keys.begin();
		TCtnr ctnr;
		for(auto val: valGen) {
			ctnr[*keyIt++] = val;
		}
		return std::move(ctnr);
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::SKDictT(std::initializer_list<TKeyVal> lst):
		mValue{lst}
	{
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::SKDictT(const SKDict& dict) {
		for(auto&& [pKey0, pVal0]: dict.mValue.mDict) {
			auto pKey = BinONObj::Cast<TKeyWrap>(pKey0);
			mValue[static_cast<TKey>(pKey->mValue)] = pVal0;
		}
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::SKDictT(const TCtnr& ctnr): mValue{ctnr} {
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::SKDictT(TCtnr&& ctnr) noexcept: mValue{std::move(ctnr)} {
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::operator TCtnr&() noexcept {
		return mValue;
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::operator const TCtnr&() const noexcept {
		return mValue;
	}
	template<typename K, typename Ctnr>
	SKDictT<K,Ctnr>::operator bool() const noexcept {
		return mValue.size() > 0u;
	}
	template<typename K, typename Ctnr>
	auto SKDictT<K,Ctnr>::typeCode() const noexcept -> CodeByte {
		return kSKDictCode;
	}
	template<typename K, typename Ctnr>
	void SKDictT<K,Ctnr>::encodeData(TOStream& stream, bool requireIO) const {
		EncodeData(mValue, stream, requireIO);
	}
	template<typename K, typename Ctnr>
	void SKDictT<K,Ctnr>::decodeData(TIStream& stream, bool requireIO) {
		mValue = DecodeData(stream, requireIO);
	}
	template<typename K, typename Ctnr>
	auto SKDictT<K,Ctnr>::makeCopy(bool deep) const -> TSPBinONObj {
		if(deep) {
			auto pCopy = std::make_shared<SKDictT<K,Ctnr>>();
			auto& dict = pCopy->mValue;
			for(auto&& [key, val]: mValue) {
				dict[key] = val->makeCopy(deep);
			}
			return std::move(pCopy);
		}
		else {
			return std::make_shared<SKDictT<K,Ctnr>>(*this);
		}
	}
	template<typename K, typename Ctnr>
	auto SKDictT<K,Ctnr>::clsName() const noexcept -> std::string {
		constexpr bool kCtnrIsUMap
			= std::is_same_v<Ctnr, std::unordered_map<K,TSPBinONObj>>;
		std::ostringstream oss;
		oss << "SKDictT<" << (kCtnrIsUMap ? "unordered_map" : "DICT")
			<< '<' << TypeInfo<K>::TypeName() << ">>";
		return std::move(oss).str();
	}
	template<typename K, typename Ctnr>
	void SKDictT<K,Ctnr>::printArgsRepr(std::ostream& stream) const {
		bool first = true;
		for(auto&& [key, val]: mValue) {
			if(first) {
				first = false;
			}
			else { stream << ", "; }
			stream << '{';
			PrintRepr(key, stream);
			stream << ", ";
			val->printRepr(stream);
			stream << '}';
		}
	}

	//---- SDictT --------------------------------------------------------------

	template<typename K, typename V, typename Ctnr>
	void SDictT<K,V,Ctnr>::EncodeData(
		const TCtnr& v, TOStream& stream, bool requireIO)
	{
		RequireIO rio{stream, requireIO};
		UIntObj::EncodeData(v.size(), stream, kSkipRequireIO);

		EncodeElems<TKey>(
			PipeGenRefs<TKeyRW>(
				IterGen{v.begin(), v.end()},
				[](auto& kv) -> TKeyRW { return const_cast<TKey&>(kv.first); }
			), stream, kSkipRequireIO);

		EncodeElems<TVal>(
			PipeGenRefs<TValRW>(
				IterGen{v.begin(), v.end()},
				[](auto& kv) -> TValRW { return const_cast<TVal&>(kv.second); }
			), stream, kSkipRequireIO);
	}
	template<typename K, typename V, typename Ctnr>
	auto SDictT<K,V,Ctnr>::DecodeData(TIStream& stream, bool requireIO)
		-> TCtnr
	{
		RequireIO rio{stream, requireIO};
		auto keys = SListT<TKey>::DecodeData(stream, kSkipRequireIO);
		auto valGen = DecodedElemsGen<TVal>(
			stream, keys.size(), kSkipRequireIO);
		auto keyIt = keys.begin();
		TCtnr ctnr;
		for(auto val: valGen) {
			ctnr[*keyIt++] = std::move(val);
		}
		return std::move(ctnr);
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::SDictT(std::initializer_list<TKeyVal> lst):
		mValue{lst}
	{
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::SDictT(const SDict& dict) {
		for(auto&& [pKey0, pVal0]: dict.mValue.mDict) {
			auto pKey = BinONObj::Cast<TKeyWrap>(pKey0);
			auto pVal = BinONObj::Cast<TValWrap>(pVal0);
			mValue[static_cast<TKey>(pKey->mValue)]
				= static_cast<TVal>(pVal->mValue);
		}
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::SDictT(const TCtnr& ctnr): mValue{ctnr} {
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::SDictT(TCtnr&& ctnr) noexcept: mValue{std::move(ctnr)} {
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::operator TCtnr&() noexcept {
		return mValue;
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::operator const TCtnr&() const noexcept {
		return mValue;
	}
	template<typename K, typename V, typename Ctnr>
	SDictT<K,V,Ctnr>::operator bool() const noexcept {
		return mValue.size() > 0u;
	}
	template<typename K, typename V, typename Ctnr>
	auto SDictT<K,V,Ctnr>::typeCode() const noexcept -> CodeByte {
		return kSDictCode;
	}
	template<typename K, typename V, typename Ctnr>
	void SDictT<K,V,Ctnr>::encodeData(TOStream& stream, bool requireIO) const {
		EncodeData(mValue, stream, requireIO);
	}
	template<typename K, typename V, typename Ctnr>
	void SDictT<K,V,Ctnr>::decodeData(TIStream& stream, bool requireIO) {
		mValue = DecodeData(stream, requireIO);
	}
	template<typename K, typename V, typename Ctnr>
	auto SDictT<K,V,Ctnr>::makeCopy(bool deep) const -> TSPBinONObj {
		return std::make_shared<SDictT<K,V,Ctnr>>(*this);
	}
	template<typename K, typename V, typename Ctnr>
	auto SDictT<K,V,Ctnr>::clsName() const noexcept -> std::string {
		constexpr bool kCtnrIsUMap
			= std::is_same_v<Ctnr, std::unordered_map<K,V>>;
		std::ostringstream oss;
		oss << "SDictT<" << (kCtnrIsUMap ? "unordered_map" : "DICT")
			<< '<' << TypeInfo<K>::TypeName()
			<< ',' << TypeInfo<V>::TypeName() << ">>";
		return std::move(oss).str();
	}
	template<typename K, typename V, typename Ctnr>
	void SDictT<K,V,Ctnr>::printArgsRepr(std::ostream& stream) const {
		bool first = true;
		for(auto&& [key, val]: mValue) {
			if(first) {
				first = false;
			}
			else { stream << ", "; }
			stream << '{';
			PrintRepr(key, stream);
			stream << ", ";
			PrintRepr(val, stream);
			stream << '}';
		}
	}
}

#endif
